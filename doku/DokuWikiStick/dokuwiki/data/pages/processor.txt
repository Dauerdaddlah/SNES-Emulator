[[https://github.com/gilligan/snesdev/blob/master/docs/65816.txt]]
[[http://datasheets.chipdb.org/Western%20Design/w65c816s.pdf]]
{{ :w65c816s.pdf |}}

Das SNES hat einen abgewandelten Prozessor zum Western Digital W65C816S.
Dieser arbeitet mit 92 Operationen, 24 Addressmodes, 6 16-BIT Register(A, PC, X, Y, D, S) und 3 8-BIT Registern (P, PBR, DBR)

====== Allgemein ======

Der SNES-Prozessor arbeitet Little Endian (LE).
Das heißt Words (Java Shorts) werden in der Reihenfolge Low-Byte High-Byte gespeichert, Long in der Reihenfolge Low-Byte High-Byte Long-Byte.

====== Register ======
Um arbeiten zu können hat der Prozessor eine Anzahl an Register, welcher (mehr oder minder) beliebig genutzt werden können.
Ein Register ist immer 8- oder 16-BIT groß - ein 16-BIT Register kann aber auch als 8-BIT Register verwendet werden.
wird ein 'volles' Register ($FF bei 8-BIT, $FFFF bei 16-BIT) weiter erhöht oder ein 'leeres' Register ($0000) gesenkt so gibt es einen Überlauf ($FF -> $00).
**Achtung** wird ein 16-BIT Register als 8-BIT verwendet, so passirt der Überlauf auch auf 8-BIT.
Sprich wird z. B. der Accumulator als 8-BIT genutzt und hat den Wert $12FF wird sein nächster Wert $1200 sein und nicht $1300.


^ Register ^ Größe ^ Beschreibung ^
| PC | 16-BIT | **P**rogram **C**ounter - die 16-BIT Adresse innerhalb der aktuellen Bank (PBR) welche aktuel selektiert ist. Diese Adresse wird genutzt, um den nächsten Befehl zu holen oder um Addressmodi aufzulösen |
| P | 8-BIT | Statusregister - hält 8 Status (1 je Bit) als Folge der vorangegangenen Operationen |
| PBR | 8-BIT | **P**rogram **B**ank **R**egister - enthält die Bank für den aktuellen/nächsten Befehl (PC). Wird ebenfalls für einige Addressmodi verwendet |
| DBR | 8-BIT | **D**ata **B**ank **R**egister - wie PBR, wird für einige Addressmodi verwendet |
| A | 8/16-BIT | **A**ccumulator - Der accumulator wird für so ziemlich alle internen REchnungen verwendet, er ist das 'Hilfsregister'. Er hält **immer** 16-BIT, je nach Prozessormodus und P wird er jedoch u. U. als 8-BIT Register verwendet. In diesem Fall bleibt das höhere Byte erhalten und kann mit einer speziellen Operation als zusätzlicher Speicher verwendet werden. |
| X/Y | 8/16-BIT | das X und das Y-Register ist jeweils ein weiteres Hilfsregister, wie der Accumulator um Aktionen auszuführen. Je nach P wird es als 8 oder 16-BIT Register verwendet. Wenn es als 8-BIT Register genutzt wird ist das höhere (ungenutzte) Byte immer $00 |
| D | 16-BIT | **D**irect Register - wird für alle Direct-Addressmodi verwendet. Das Direct Register wird immer dann verwendet, wenn der Addressmodus nur 1 Byte erhält und soll die Page darstellen. Insofern hat diesen Register in der Regel die Form $xx00. Sollte das untere Byte einen anderen Wert haben führt dies in der Regel zu einem zusätzlich benötigten Cycle |
| S | 8/16-Bit | **S**tack Register - verwaltet die nächste zu verwendende Addresse auf dem Stack. Je nach Prozessormodus wird dieser Pointer asl 8- oder 16-BIT verwendet. Im 8-BIT modus ist dabei das höhere Byte immer $01 |

===== Program Counter (PC) =====

Der Program Counter ist ein 16-BIT Register, das sehr eng mit dem PBR zusammenarbeiten.
Er zeigt auf die nächste auszuführende Instruktion innerhalb des PBR (PBR|PC bilden die effektive Addresse).
wann immer ein Wert mit Hilfe des PC gelesen wird, wird dieser um 1 erhöht.
Werden für den Addressmodus noch weitere Werte benötigt werden diese (soweit nicht anders beschrieben) mit Hilfe des PC geholt.

==== Direct Page/Zero Page (D) ====

Die Zero Page aus dem originalen 6502 (NES) wurde im SNES Prozessor nach Direct Page umbenannt.
Immer wenn ein Addressmodus mit einem Byte gewählt wird bestimmt die Direct Page die Page-Adresse (mittleres Byte)
Die Direct Page ist 16-Bit groß und kann dementsprechend neben der Page auch einen Versatz für das Byte beinhalten, jedoch wird in dem Fall (Low-Byte != 0) ein Cycle mehr benötigt.
Im Emulation Mode ist die Adressierung in der Direct Page gefangen, sprich ein Rollover nach $FF beginnt wieder bei $00 der Direct Page (NES).
Im Native Mode hingegen geht ein Rollover in die nächste Page.
Beispiel:
<code>
LDX #$2c
LDA ($E0,X)
</code>
In Emulation Mode ergibt dies die Adresse $0C, im Native Mode $10C

==== Stack Pointer (S) ====

Der Stack Pointer ist 16-Bit groß und zeigt auf die nächste leere (zu nutzende) Speicheradresse für den Stack.
Im Emulation Mode wird das High-Byte (Page) immer auf $01 gezwungen (NES).
Der Stack Pointer wird entsprechend im Emulation Mode als 8-Bit Register gehandelt.
In der Regel ist/wird der Stack Pointer zum Programmstart auf $01FF initialisiert.
Wird ein Element auf dem Stack abgelegt, so wird der Wert auf die Adresse des Stack Pointers gelegt und dieser anschließend um 1 gesenkt.
Der Pull geschieht entsprechend umgekehrt, erst wird der Pointer incrementiert und anschließend wird der Wert gelesen.

==== Program Bank Register (PBR) ====

Der PBR ist ein 8-Bit Register welches die Bank zum PC beschreiben.
Der PBR wird immer verwendet, wenn das nächste Byte im Ablauf geholt wird, entweder die Instruktion, oder direkt darauf folgenden Bytes für den Addresmodus.

==== Data Bank register (DBR) ====

Der DBR ist ein 8-Bit Register welches die Bank für bestimmte Addressmodi hält.

==== Status Register (P) ====

das StatusRegister besteht aus den Flags NVMXDIZC.
Im Emulation Mode ist es NV1BDIZC.
Das M- und X-Flag dient dazu Accumulator, X und Y zwischen 8 und 16-Bit zu wechseln.
Dementsprechend werden diese im Emulation Mode anders verwendet:
Die Flags:
  * N - Negative steht für einen negativen Wert.
  * V - Overflow zeigt an, wenn für eine Aktion ein zusätzliches Byte benötigt worden wäre
  * M - Memory/Accumulator schaltet den Accumulator auf 16-Bit wenn auf 0 gesetzt. Im Emulation Mode ist dieser auf 1 gezwungen
  * X - Index schaltet X und Y auf 16-Bit wenn auf 0 gesetzt. Wird im Emulation Mode auf 1 gesetzt und als B gehandelt.
  * B - Break beschreibt das X-Flag im Emulation mode. Es eig. immer 1 im Register und wird bei einem Interrupt als 0 gepusht, wenn der Interrupt nicht durch ein BRK ausgelöst wurde.
  * D - decimal, wenn auf 1, dann werden ADC und SBC im decimal mode berechnet ($20 - $04 = $16)
  * I - IRQ-Disable wenn auf true, werden keine Interrupts ausgeführt außer NMI
  * Z - Zero, wird bei null gestzt, zeigt ebenfalls gleichheit an. beq - branch if equal springt bei Z = 1
  * C - Carry wird als zusätzliches Bit für einige Operationen verwendet. C und XCE sind der einzige Weg des Prozessormodus anzupassen.

{{:statusregister.png?direct&800|}}

==== Accumulator (A) ====

Der Accumulator ist einer der Hauptregister mit denen gearbeitet wird.
Er wird hauptsächlich verwendet, wenn man Daten lesen schreiben und verrechnen möchte.
Er ist 16-Bit groß und kann im 8-Bit Modus verwendet werden (je nach P).
Im Gegensatz zu allen anderen "variablen" Register behält der Accumulator den Wert seines High-Byte bei.
So kann das High-Byte im 8-Bit modus als zusätzlicher Speicher verwendet werden.
Mit Hilfe der XBA instruktion kann so der Wert des High und des Low-Bytes getauscht werden.

je nach Situation hat der Accumulator drei Namen, A, B und C.
Mit C ist der Accumulator immer als 16-Bit Register bezeichnet.
Dementsprechend tauscht die Instruktion TCS immer die kompletten 16-Bit von A (C) nach S.
B beschreibt immer das High-Byte des Accumulators.
A beschreibt je nach Kontext entweder den Accumulator allgemein oder nur das LOW-Byte (z. B. in XBA - exchange B and A).
Einige Assembler nehmen diese Trennund nicht 100% und erlauben so auch z. B. die Operation TAS als Synonym für TCS.

==== X/Y Register (X/Y) ====

X und Y sind 2 Hilfsregister, welche zusammen mit dem Accumulator verwendet werden.
Sie sind 16-BIT groß und können je nach P auch als 8-Bit verwendet werden.
Werden Sie als 8-Bit verwendet ist das High-Byte immer 0

===== Prozessormodi =====

Der Prozesser hat 2 Modi, Emulation und Native.
Bei Start des Prozessors ist dieser immer im Emulation Mode und der PC zeigt auf den Reset-Vector.
Der Modus wird über die XCE-Instruktion gesetzt, wobei ein gesetztes C-Flag den Native-Mode aktiviert.
Im Emulation Mode ist der Prozessor kompatibel zum NES 6502, dementsprechend sind alle variablen Register im 8-BIT Modus.
Im Native-Mode können A, X, und Y je nach P als 16-Bit verwendet werden - S ist automatisch 16-BIT.
Die Interrupt-Handler sind unterschiedlich je nach Modus:
^ Adresse Emulation ^ Vector Emulation ^ Adresse Native ^ Vector Native ^
| $FFF4-5 | COP     | $FFE4-5 | COP |
| $FFF6-7 |         | $FFE6-7 | BRK |
| $FFF8-9 | ABORT   | $FFE8-9 | ABORT |
| $FFFA-B | NMI     | $FFEA-B | NMI |
| $FFFC-D | RESET   | $FFEC-D | RESET (ungenutzt) |
| $FFFE-F | IRQ/BRK | $FFEE-F | IRQ |

Da der Prozessor beim Startup immer im Emulation-Mode ist wird der Reset-Vector vom Native-Mode nicht genutzt.

===== Stack Operationen =====

Auf den Stack können einzelne Bytes oder Word gepusht werden.
Wenn immer ein Wert auf den Stack gepusht wird, wird der Stackpointer um 1 reduziert.
Wird ein Word gepusht, wird zuerst das High-Byte und anschließend das Low-Byte gepusht, sodass das Word im Speicher wieder in Little-Endian steht.
Wird ein Byte gepusht, wird zuerst der Wert im gespeichert und anschließend der Pointer dekrementiert.

===== Interrupts =====

Wenn ein Interrupt ausgelöst wird werden alle nötigen Register auf den Stack gepusht und je nach Modus zum Interrupthandler gesprungen.
Zusätzlich wird PBR auf 0 gesetzt, sodass sich ein Interrupthandler immer in der Bank 0 befindet.
Außerdem wird das IRQDisable-Flag auf 1 gesetzt (D auf 0), um weitere interrupts zu vermeiden.
Mithilfe von rti (0x40) wird zum vorherigen Zustand zurückgesprungen.
Folgende Werte werden in dieser Reihenfolge gepusht und bei rti umgedreht gepullt:
  * PBR (Native Mode)
  * PC (Short)
  * P

Ein Interrupt findet nicht statt, wenn das IRQ-Disable flag true ist.
Ausnahme hiervon ist der NMI, welcher nicht über P verhindert werden kann.